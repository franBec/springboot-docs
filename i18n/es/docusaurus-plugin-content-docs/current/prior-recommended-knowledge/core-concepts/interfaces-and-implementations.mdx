---
sidebar_position: 6
title: Interfaces e Implementaciones
---

- **Una Interface es el "Qué".** Es un contrato. Una promesa. Te dice _qué_ puede hacer una cosa, pero no tiene ni idea de _cómo_ se hace. Pensá en un tomacorriente de la pared. Sabés que podés enchufar una lámpara y tener electricidad (el "qué"). No necesitás saber sobre la planta de energía, los transformadores o las ratas corriendo en una rueda que generan la energía (el "cómo"). El tomacorriente es la interface.
- **Una Implementación es el "Cómo".** Esta es la realidad desordenada. Es el código real que hace el trabajo prometido por la interface. Es la planta de energía, el cableado en tus paredes, y tal vez esa pobre rata. Es la clase concreta que tiene los métodos y la lógica.

| Concepto           | Analogía         | En Código                                             |
| ------------------ | ---------------- | ----------------------------------------------------- |
| **Interface**      | El tomacorriente | `public interface LightSwitch`                        |
| **Implementación** | La red eléctrica | `public class EdisonPowerGrid implements LightSwitch` |

**¿Por Qué Me Debería Importar?**

1.  **Tu Código Se Vuelve Flexible:**
    Digamos que empezás con un `UserRepository` falso que solo devuelve una lista hardcodeada de usuarios. Tu implementación es simple. Pero tu código de aplicación no le importa. Solo habla con la interface `UserRepository`.
    Más tarde, cuando estés listo para usar una base de datos real, simplemente creás un `PostgresUserRepository`. Cambiás la _implementación_. El resto de tu código? No cambia en absoluto. Cambiaste el "cómo" sin tocar el "qué". Esto es enorme.

2.  **Las Pruebas Se Vuelven Fáciles:**
    Si tu `BillingService` necesita un `PaymentGateway` para funcionar, no querés pegarle a una API de tarjetas de crédito real cada vez que corrés una prueba unitaria. Eso es lento, caro, y te genera mails enojados de contabilidad.
    En cambio, le das una implementación _mock_ de la interface `PaymentGateway`. Una falsa que solo pretende funcionar. Esto te permite probar tu `BillingService` de forma aislada, y es rápido y gratis.

3.  **Oculta las Partes Feas:**
    El código del mundo real es desordenado. Las implementaciones lidian con conexiones de base de datos, quirks raros de APIs y todo tipo de otros dolores de cabeza. Una interface es una fachada limpia y hermosa que oculta toda esa complejidad. Permite que otros desarrolladores usen tu componente sin necesitar saber sobre el incendio de basura de complejidad adentro.
