---
sidebar_position: 3
title: Primeros tests
---

import {
  MainFileTree,
  FileTree,
  BuildGradle,
  FindByIdPortInTests,
  ApiResponseMatchersJavaCode,
  ApiResponseMatchersKtCode,
  ApiResponseMatchersGroovyCode,
  FilmRestControllerTests,
  ControllerAdvice,
  TestErrorLog,
  MapperSpec,
  JacocoReportJava,
  JacocoReportKt,
  JacocoReportGroovy,
  ControllerAdviceTests,
  LoggingIntegrationTests,
} from '@site/src/components/docs/testing/first-tests';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';
import GithubBranchInfo from '@site/src/components/github-branch-info';

<GithubBranchInfo branch="feature/first-tests" />

## Estrategia de testing

### ElegÃ­ un framework

- Para la aplicaciÃ³n **Java** Spring Boot vamos a elegir **JUnit + Mockito**: es el estÃ¡ndar de facto, el que siempre preguntan en entrevistas, y el que se espera que conozcas.
- Para la aplicaciÃ³n **Kotlin** Spring Boot vamos a elegir **JUnit + MockK**: herramientas nativas de kotlin + mocking pensado para kotlin.
- Para el proyecto **Groovy** Spring Boot vamos a elegir **Spock**, ya que es la elecciÃ³n natural con menos fricciÃ³n.

### JaCoCo

[JaCoCo (Java Code Coverage)](https://www.jacoco.org/jacoco/) te dice quÃ© lÃ­neas de cÃ³digo tus tests realmente ejecutan. Es la herramienta estÃ¡ndar de cobertura para proyectos JVM.

Cuando corrÃ©s la tarea `test` o `jacocoTestReport`, JaCoCo va a generar reportes en HTML (para humanos) y XML (para herramientas de CI) en `build/reports/jacoco/test`.

### QuÃ© archivos testear

<MainFileTree />

| SÃ­mbolo | Tipo de Prueba          | DescripciÃ³n                                                             |
| ------- | ----------------------- | ----------------------------------------------------------------------- |
| ğŸ”´      | `@SpringBootTest`       | Prueba de integraciÃ³n con contexto completo                             |
| ğŸŸ£      | `@ContextConfiguration` | Contexto parcial (solo beans especÃ­ficos) [Usado en el proyecto GROOVY] |
| ğŸŸ¡      | `@WebMvcTest`           | Prueba de capa web (slice test)                                         |
| ğŸ”¶      | MockMvc Standalone      | MockMvc sin contexto completo de Spring                                 |
| ğŸŸ¢      | Prueba Unitaria         | Prueba unitaria pura                                                    |
| âšª      | Ignorado                | No requiere prueba (config/interfaz/POJO)                               |

```txt
â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ESPECTRO DE PRUEBAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶

UNITARIO                                                INTEGRACIÃ“N
RÃPIDO                                                        LENTO
AISLADO                                                    CONECTADO

ğŸŸ¢â”€â”€â”€â”€â”€â”€â”€â”€ğŸ”¶â”€â”€â”€â”€â”€â”€â”€â”€ğŸŸ¡â”€â”€â”€â”€â”€â”€â”€â”€ğŸŸ£â”€â”€â”€â”€â”€â”€â”€â”€ğŸ”´
 â”‚         â”‚         â”‚         â”‚         â”‚
 â”‚         â”‚         â”‚         â”‚         â””â”€â”€ Spring Boot Completo
 â”‚         â”‚         â”‚         â””â”€â”€ Contexto Parcial
 â”‚         â”‚         â””â”€â”€ Solo Capa Web
 â”‚         â””â”€â”€ MockMvc Independiente
 â””â”€â”€ Prueba Unitaria Pura

âšª = Fuera del espectro (no necesita prueba)
```

<FileTree />

## Dependencias

<BuildGradle />

## ğŸŸ¢ Unit Tests

Los tests unitarios no involucran a Spring en absoluto. Estos son mÃ¡s rÃ¡pidos de correr y perfectos para testear lÃ³gica de negocio en completo aislamiento.

`FindByIdPortInImpl` actualmente solo devuelve una pelÃ­cula hardcodeada. No tiene mucho sentido hacer testing profundo acÃ¡ todavÃ­a, pero al menos verifiquemos que el servicio se instancie y devuelva algo:

<FindByIdPortInTests />

## ğŸ”¶ ğŸŸ¡ Slice Tests

### ğŸŸ¡ Capa Web

Estamos testeando tres cosas acÃ¡:

- **Comportamiento del endpoint REST**: Â¿El controller mapea requests correctamente y devuelve las respuestas esperadas?
- **Manejo de excepciones**: Cuando las cosas salen mal, Â¿la estructura de respuesta de error se ve bien?
- **Estructura de respuesta JSON**: Â¿El JSON final coincide con lo que promete nuestro contrato de API?

Para hacer nuestras aserciones mÃ¡s legibles, primero vamos a crear algunos matchers custom para la estructura de respuesta de nuestra API:

<Tabs groupId="language" queryString>
  <TabItem value="java" label="Java" default>
    <ApiResponseMatchersJavaCode />
  </TabItem>
  <TabItem value="kotlin" label="Kotlin">
    <ApiResponseMatchersKtCode />
    <Admonition type="tip" title="Kotlin Extension Function">
      Al extender `MockMvcResultMatchersDsl`, nuestros matchers custom se
      integran perfectamente con el DSL de Kotlin de Spring. Se pueden llamar
      directamente dentro del bloque `andExpect`, haciendo que el cÃ³digo de test
      lea como una parte nativa del framework.
    </Admonition>
  </TabItem>
  <TabItem value="groovy" label="Groovy">
    <ApiResponseMatchersGroovyCode />
    <Admonition type="tip" title="Groovy Trait">
      Un trait es como una interfaz con implementaciÃ³n que se puede mezclar en
      clases. Al implementar este trait en tus especificaciones Spock, los
      mÃ©todos matcher se vuelven disponibles como si estuvieran definidos
      directamente en tu clase de test, sin necesidad de imports estÃ¡ticos. A
      diferencia de las clases base abstractas, podÃ©s implementar mÃºltiples
      traits, manteniendo tu jerarquÃ­a de tests flexible.
    </Admonition>
  </TabItem>
</Tabs>

Ahora escribamos el test del `@RestController` propiamente dicho usando un enfoque de slice testing con `@WebMvcTest`, que crea un contexto mÃ­nimo de Spring enfocado en la capa web.

<FilmRestControllerTests />

Cuando corremos los tests, encontramos que este falla:

<TestErrorLog />

EsperÃ¡bamos un 400 (Bad Request) cuando pasamos un ID invÃ¡lido (0), pero obtuvimos un 500. Esto nos dice que nuestro `ControllerAdvice` no estÃ¡ manejando `ConstraintViolationException` correctamente. EstÃ¡ siendo atrapado por el manejador genÃ©rico de `Exception` y devolviendo un estado 500.

Arreglemos el `ControllerAdvice` agregando un manejador explÃ­cito para `ConstraintViolationException` que devuelve `BAD_REQUEST` (400) en vez de dejarlo pasar al manejador genÃ©rico de 500:

<ControllerAdvice />

DespuÃ©s de este arreglo, todos los tests pasan. Ahora tenemos confianza de que nuestro controller maneja correctamente los caminos felices, errores de validaciÃ³n, y excepciones inesperadas.

### ğŸ”¶ MockMvc Standalone

El objetivo de estos tests es verificar que nuestro `ControllerAdvice` maneja diferentes escenarios de excepciones correctamente. Testeamos que los errores de validaciÃ³n devuelvan cÃ³digos de estado HTTP y estructuras de respuesta apropiadas, asegurando que nuestra API proporcione respuestas de error consistentes en diferentes modos de falla.

<ControllerAdviceTests />

## ğŸŸ£ ğŸ”´ Integration Tests

### ğŸŸ£ Contexto parcial

<Admonition type="info" title="Ejemplo especÃ­fico de Groovy">
  Esta secciÃ³n aplica principalmente al proyecto Groovy ya que es el Ãºnico donde
  inicializar el mapper parcialmente tiene sentido conceptualmente. Sin embargo,
  este enfoque puede aplicarse a proyectos Java y Kotlin en escenarios donde
  necesitÃ¡s testear componentes con dependencias parciales o cuando mockeamos
  ciertos beans mientras testeamos otros.
</Admonition>

El objetivo de este test es demostrar cÃ³mo testear la funcionalidad del mapper con un contexto de Spring parcialmente inicializado. Queremos verificar que nuestro mapper pueda manejar casos extremos y entradas invÃ¡lidas correctamente sin necesidad del contexto completo de la aplicaciÃ³n.

<MapperSpec />

### ğŸ”´ Test de integraciÃ³n con contexto completo

El objetivo de este test es verificar que la configuraciÃ³n de logging de nuestra aplicaciÃ³n funciona correctamente y que todos los componentes registran eventos como se espera. Queremos asegurar que los eventos importantes sean capturados y formateados correctamente en nuestros logs.

<LoggingIntegrationTests />

## Ver el reporte de JaCoCo

<Tabs groupId="language" queryString>
  <TabItem value="java" label="Java" default>
    <JacocoReportJava />
  </TabItem>
  <TabItem value="kotlin" label="Kotlin">
    <JacocoReportKt />
  </TabItem>
  <TabItem value="groovy" label="Groovy">
    <JacocoReportGroovy />
    <Admonition
      type="warning"
      title="JaCoCo Limitations with Groovy Spring Boot Projects"
    >
      JaCoCo funciona a nivel de bytecode, pero Groovy genera bytecode
      significativamente diferente al que escribÃ­s en cÃ³digo fuente. Para
      proyectos Groovy (especialmente con Spring Boot), deberÃ­as generalmente
      ignorar las columnas "Instructions" y "Branches" y enfocarte casi
      exclusivamente en Line Coverage.
    </Admonition>
  </TabItem>
</Tabs>

AcÃ¡ estÃ¡ lo que significa cada columna en un reporte de cobertura de JaCoCo:

| Columna                  | Significado                                                             | Notas / CuÃ¡ndo Importar                            |
| ------------------------ | ----------------------------------------------------------------------- | -------------------------------------------------- |
| **Name**                 | El package, clase, archivo, o mÃ©todo siendo medido                      | La fila **Total** agrega todas las entradas        |
| **Instruction Coverage** | Porcentaje de instrucciones de bytecode JVM ejecutadas                  | Muy detallado; puede ser engaÃ±oso para Groovy      |
| **Branch Coverage**      | Porcentaje de branches condicionales ejecutados (`if`, `switch`, loops) | Genial para atrapar caminos de lÃ³gica no testeados |
| **Missed Complexity**    | Complejidad ciclomÃ¡tica no cubierta por tests                           | Indica flujo de control riesgoso o no testeado     |
| **Total Complexity**     | Complejidad ciclomÃ¡tica total del cÃ³digo                                | Valores mÃ¡s altos significan lÃ³gica mÃ¡s compleja   |
| **Missed Lines**         | NÃºmero de lÃ­neas ejecutables de cÃ³digo no corrida                       | Basado en lÃ­neas con bytecode                      |
| **Total Lines**          | Total de lÃ­neas ejecutables de cÃ³digo                                   | MÃ©trica de coverage mÃ¡s intuitiva                  |
| **Missed Methods**       | MÃ©todos nunca invocados por tests                                       | Bueno para detectar APIs no testeadas              |
| **Total Methods**        | NÃºmero total de mÃ©todos                                                 | Incluye constructores y lambdas                    |
| **Missed Classes**       | Clases nunca cargadas durante tests                                     | Indicador de completitud de tests de alto nivel    |
| **Total Classes**        | NÃºmero total de clases                                                  | Incluye clases internas y anÃ³nimas                 |
