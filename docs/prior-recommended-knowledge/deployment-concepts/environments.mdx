---
sidebar_position: 1
title: Environments
---

import {
  ApplicationYml,
  ApplicationDevYml,
  ApplicationProdYml,
  ApplicationYmlWithProfile,
} from '@site/src/components/docs/prior-recommended-knowledge/environments';

When developing and deploying software like a Spring Boot application, you rarely just push code straight to live users. Instead, applications typically move through several **Environments**. Understanding these environments is crucial for safe, reliable, and efficient development workflows.

## What Are Environments?

Environments are distinct, isolated setups where your application runs. Each environment serves a specific purpose in the software development lifecycle. The most common environments are:

- **Development (dev):** This is where developers write and test code locally on their machines or sometimes on a shared development server. The focus is on rapid iteration, debugging, and feature implementation. Configuration might be simplified (e.g., using an in-memory database).
- **Testing (test / staging / QA):** This environment aims to closely replicate the production setup. It's used for various types of testing:
  - **Integration Testing:** Verifying that different parts of the application (or different microservices) work together correctly.
  - **User Acceptance Testing (UAT):** Allowing stakeholders or QA teams to test features before they go live.
  - **Performance/Load Testing:** Checking how the application behaves under stress.
    Testing environments isolate testing activities from real users and production data.
- **Production (prod):** This is the live environment where your end-users interact with the application. The primary focus here is stability, performance, reliability, and security. Configurations point to real databases, external services, and use production-level resources.

```txt
    ┌──────────────────────────────────────────────────────────────────┐
    │                      Application Lifecycle                       │
    └──────────────────────────────────────────────────────────────────┘

    ┌─────────────┐       ┌─────────────┐       ┌─────────────┐
    │     DEV     │──────▶│    TEST     │──────▶│    PROD     │
    └─────────────┘       └─────────────┘       └─────────────┘
          │                     │                     │
          ▼                     ▼                     ▼
    ┌─────────────┐       ┌──────────────┐       ┌─────────────┐
    │ • Write code│       │ • QA Testing │       │ • Real users│
    │ • Debug     │       │ • Integration│       │ • Live data │
    │ • H2 DB     │       │ • Test DB    │       │ • Production│
    │ • Fast iter.│       │ • Staging    │       │   database  │
    └─────────────┘       └──────────────┘       └─────────────┘
```

## Why Do Environments Exist?

Using different environments is essential for several reasons:

1. **Isolation and Safety:** The most critical reason is to prevent untested or broken code from affecting real users. You wouldn't test experimental engine parts on a plane full of passengers; similarly, you don't test new code directly in production.
2. **Configuration Differences:** Each environment often needs different settings. For example:
   - **Databases:**
     - In **dev**, you might want a fast, disposable in-memory database like H2 for quick startups.
     - In **test**, you need to connect to a dedicated test database (perhaps a clone of the prod schema but with test data).
     - In **prod**, you connect to the real, live database holding actual user data.
   - **External services & api keys**: Dev/Test environments might use sandbox versions of third-party APIs with test keys, while production uses live APIs with real keys and potentially different rate limits.
   - **Logging**: You might want verbose `DEBUG` logging in dev, but only `INFO` or `WARN` level logging in production to avoid excessive noise and performance impact.
   - **Resources**: Dev/Test might run with lower memory/CPU limits, while production needs robust resources.
3. **Testing Fidelity**: Test environments allow you to validate your application in a setup that closely mirrors production, increasing confidence that it will work correctly when deployed.
4. **Controlled Rollouts**: Features can be enabled or tested in staging before being released to all users in production (often using feature flags).

## Spring Boot Profiles

Spring Boot provides an elegant solution for managing environment-specific configurations using [Profiles](https://docs.spring.io/spring-boot/reference/features/profiles.html). A profile is essentially a label for a set of configuration settings.

Here's how it typically works:

1. **The default configuration** (`application.yml` or `application.properties`):
   - This file, located in `src/main/resources`, contains configuration properties common to _all_ environments or settings that serve as a baseline.

     <ApplicationYml />

2. **Profile-specific configurations** (`application-{profile}.yml`):
   - These files are also placed in `src/main/resources`.
   - You create additional configuration files named `application-{profile}.yml` (or `.properties`) for each environment, replacing `{profile}` with the profile name (e.g., `dev`, `test`, `prod`).
   - Properties defined in a profile-specific file **override** the properties defined in the default `application.yml` when that profile is active.

     <ApplicationDevYml />
     <ApplicationProdYml />

3. **Activating profiles**:
   - You tell Spring Boot which profile(s) to activate when the application starts. Spring will load `application.yml` first, and then load the `application-{profile}.yml` for the active profile, overriding any overlapping properties.
   - Common ways to activate a profile:
     - **Environment Variable:** `SPRING_PROFILES_ACTIVE=prod` (Very common in deployment scripts/containers).
     - **JVM System Property:** `-Dspring.profiles.active=prod` (Passed during startup).
     - **In `application.yml`:** (Less common for _activating_ a specific env, but possible).

       <ApplicationYmlWithProfile />

By using profiles and separate configuration files, you can manage the different settings required for your dev, test, and production environments, ensuring your application behaves correctly and safely in each context.
