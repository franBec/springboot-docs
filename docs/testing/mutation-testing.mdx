---
sidebar_position: 4
title: Mutation Testing
---

import Admonition from '@theme/Admonition';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {
  FileTree,
  BuildGradle,
  PitestCoverageReportJava,
  PitestCoverageReportKt,
} from '@site/src/components/docs/testing/mutation-testing';
import GithubBranchInfo from '@site/src/components/github-branch-info';

<GithubBranchInfo branch="feature/mutation-testing" />

## What Is Mutation Testing?

[Pitest](https://pitest.org/) defines it as:

> Mutation testing is conceptually quite simple. Faults (or mutations) are automatically seeded into your code, then your tests are run. If your tests fail, then the mutation is killed, if your tests pass, then the mutation lived. The quality of your tests can be gauged from the percentage of mutations killed.

Mutation testing isn't frequently discussed in Spring Boot circles. Some reasons for its limited popularity are:

- **Performance concerns**: Mutation testing is computationally expensive, especially for large Spring codebases.
- **Complexity vs. value perception**: Many teams question whether the additional insights justify the setup complexity and runtime costs.
- **CI/CD impact**: The long execution time can disrupt fast feedback loops in CI/CD pipelines.

There is slowly increasing interest, particularly among teams with mature testing practices, but be prepared for longer build times.

### Why Mutation Testing Doesn't Make Sense In Groovy Projects

Groovyâ€™s **dynamic typing**, runtime method dispatch, operator overloading, and heavy use of **AST transformations** (`@Canonical`, `@Builder`, `@Slf4j`, Spock internals, etc.) mean that PIT mutates generated bytecode that often **does not resemble the source code** you wrote. As a result, many mutants are either meaningless, unreachable, or survive for reasons unrelated to test quality.

Mutation testing is a great fit for **Java and Kotlin**, but in Groovy projects produces noise instead of insight.

## PIT Mutation Testing

<FileTree />

Let's set up [Gradle plugin for PIT Mutation Testing](https://github.com/szpak/gradle-pitest-plugin/tree/master)

<BuildGradle />

Run the `pitest` task. When finished you will get a HTML report at `build/reports/pitest/index.html`.

<Tabs groupId="language" queryString>
    <TabItem value="java" label="Java" default>
        <PitestCoverageReportJava />
    </TabItem>
    <TabItem value="kotlin" label="Kotlin">
        <PitestCoverageReportKt />
        <Admonition type="warning" title="Pitest only includes classes in the report if it successfully generated at least one mutation (mutant) for that class">
            `FindByIdPortInImpl` and `FilmController` contain no "logic" in the eyes of the default Pitest mutators.
            1. **No Conditionals:** There are no `if`, `when`, or loops.
            2. **No Math:** There are no `+`, `-`, `*`, `/`.
            3. **No Void Calls:** Calling a constructor (which returns a value), not a void method.
            4. **Constructor Arguments:** The default Pitest mutators **do not** change hardcoded strings or numbers passed as arguments to constructors.
            5. Due to Kotlin's strict null-safety, Pitest skips generating a null mutant for simple non-nullable return types.

            The classes are missing in the report because they are too simple.
        </Admonition>
    </TabItem>

</Tabs>

## What Each Metric Means

| Metric                | What It Measures                         | Why It Matters                                                      | Good Target                   |
| --------------------- | ---------------------------------------- | ------------------------------------------------------------------- | ----------------------------- |
| **Line Coverage**     | % of code lines executed during tests    | Easy to achieve but misleading - high numbers don't mean good tests | 80%+ (industry standard)      |
| **Mutation Coverage** | % of mutations killed out of all created | The real deal - shows how many bugs your tests would catch          | ~70%+ (indicates solid tests) |
| **Test Strength**     | `Killed Mutations / Covered Mutations`   | Effectiveness of tests on code they touch                           | 80%+ (meaningful assertions)  |

Focus on **mutation coverage** and **test strength** over line coverage. A 70% mutation coverage is infinitely more valuable than 95% line coverage with weak assertions. If test strength is low but line coverage is high, your tests are executing code without verifying behavior.
