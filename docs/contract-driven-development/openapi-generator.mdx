---
sidebar_position: 3
title: OpenAPI Generator
---

import GithubBranchInfo from '@site/src/components/github-branch-info';
import Image from '@site/src/components/image';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';
import {
  FileTree,
  JavaBuildGradle,
  GroovyBuildGradle,
  KotlinBuildGradle,
  GroovyModelMapperConfig,
  RestController,
  RestControllerAdvice,
  Mapper,
  Terminal,
} from '@site/src/components/docs/contract-driven-development/openapi-generator';

<GithubBranchInfo branch="feature/openapi-generator" />

## The Problem with Manual Primary Adapters

Unless you work in microservices, a project usually has more than a few endpoints. As your domain grows, manually crafting primary adapters becomes a monumental task. It comes with a lot of drawbacks:

- **Time-consuming**: Every endpoint, every model, all by hand. It's a grind.
- **Prone to human error**: One typo, one missed field, and suddenly your API isn't doing what it's supposed to.
- **Compromises documentation and maintainability**: The moment your code deviates from your spec, your documentation is a lie, and your maintainability takes a nosedive.

<Admonition type="info" title="Real case scenario">
The [SIGEM project](https://sigem.sanluislaciudad.gob.ar/sigem/) (a [Grails monolith](https://grails.apache.org/)) boasts 76 controllers and a staggering 1102 endpoints.

    <Image
      src={
        require('@site/static/img/contract-driven-development/controllers-count-sigem.png')
          .default
      }
    />

</Admonition>

<FileTree />

## Generating Code

Let’s save us some problems by using one of the greatest libraries to ever exist: [openapi-generator](https://github.com/OpenAPITools/openapi-generator).

<Tabs groupId="language" queryString>
  <TabItem value="java" label="Java" default>
    <JavaBuildGradle />
    <Admonition type="info">

      You can find more information about the different configurations in the [Documentation for the spring Generator](https://github.com/OpenAPITools/openapi-generator/blob/master/docs/generators/spring.md).

    </Admonition>

  </TabItem>
  <TabItem value="kotlin" label="Kotlin">
    <KotlinBuildGradle />
    <Admonition type="info">

      You can find more information about the different configurations in the [Documentation for the kotlin-spring Generator](https://github.com/OpenAPITools/openapi-generator/blob/master/docs/generators/kotlin-spring.md).

    </Admonition>

  </TabItem>
  <TabItem value="groovy" label="Groovy" default>
    <GroovyBuildGradle />
    <Admonition type="info">

      - You can find more information about the different configurations in the [Documentation for the spring Generator](https://github.com/OpenAPITools/openapi-generator/blob/master/docs/generators/spring.md).
      - While a [groovy generator](https://github.com/OpenAPITools/openapi-generator/blob/master/docs/generators/groovy.md) exists, it's a client generator. For our use case (generating server-side code), it doesn't quite fit the bill. That's why we stick with the "spring" generator, which generates `.java` classes.

    </Admonition>

  </TabItem>
</Tabs>

<Admonition type="warning">
  `inputspec` must be pointing to the desired OpenAPI Specification YAML file
  (`src/main/resources/openapi.yaml`).
</Admonition>

Now that everything is set up, **run the Build Task**. When the task finishes, check the `build\generated\sources\openapi` folder. You’ll find the representation of the OpenAPI Specification (our contract) in classes, ready to be used.

## Understand the Generated Code

- **What’s Inside the Generated Code?**
  - **Models**: Java (or Kotlin) classes mirroring your OpenAPI schemas (e.g., `Film`). These include validation annotations, serialization logic, and builder patterns.
  - **API Interfaces**: Spring `@RestController` interfaces (e.g., `FilmApi`) that define your endpoints and their method signatures.
- **Why Does It Look So Complicated?** The generated code includes:
  - **Boilerplate** for OpenAPI/Spring compatibility (e.g., `@Validated`, `@Generated` annotations).
  - **Validation logic** (e.g., `@NotNull`, `@Size`) to enforce your contract.
  - **Serialization/deserialization** support (e.g., JSON ↔ Java (or Kotlin) object mapping).
- **Should I care?** No.
  - **It’s autogenerated**: Treat it like a compiled dependency. You use it, not modify it.
  - **Contract-first philosophy**: The code exactly matches your OpenAPI spec. If you need changes, update the YAML file and regenerate.
  - **Maintenance-free**: The generator handles updates, so you avoid manual refactoring.

## (Groovy Only) Mapping Groovy Classes into Java Classes

Some ground truths:

- The `openapi-spring` generator spits out `.java` classes.
- The domain logic is in `.groovy`

We're gonna need a bridge. That means mapping Groovy classes into Java counterparts.

This is where we hit a wall: Groovy's `properties` feature doesn't play nice with how Java constructors. So, [direct, trivial mapping using Groovy's native property](/optional-but-recommended-features/mapper#groovy-does-not-need-a-mapper-yet) handling is off the table here.

Now, you might be thinking, "Hey, what about [MapStruct](https://mapstruct.org/)? We used it for Java and Kotlin!" For Groovy, MapStruct isn't really an option. [Groovy's dynamic nature clashes with MapStruct's compile-time code generation](https://stackoverflow.com/questions/72197127/mapstruct-with-groovy).

This leaves us with:

- Hand-mapping, which is tedious, and error-prone task we're trying to _avoid_ with code generation in the first place
- Finding another mapping library.

[ModelMapper](https://modelmapper.org/) is a pragmatic solution that handles the object mapping gracefully in our Groovy Spring Boot project.

1. Add ModelMapper dependency (already done in `build.gradle`)
2. Create ModelMapper Configuration:

   <GroovyModelMapperConfig />

## Use the Generated Code

1. **Make the `@RestController` class implement the generated `Api` interface:**

   <RestController />

2. **Update the `Mapper` interface so it returns the generated `Response` model instead of the handwritten one:**

   <Mapper />

3. **Update the `@RestControllerAdvice` class so it returns the generated `Error` model (which models `ProblemDetail`) to keep consistency:**

   <RestControllerAdvice />

4. **Delete handwritten `FilmResponse`, it is no longer needed.**

Build and run the application. Then go to [http://localhost:8080/api/films/42](http://localhost:8080/api/films/42)

<Terminal />

## What's the Point of Generating Code?

Setting up this OpenAPI Generator might feel like performing ancient rituals just to get some code out. You might be thinking, _"Wasn't this supposed to *save* me time?"_ And to that, I say: Yes, you're investing a little pain upfront to avoid a lot of pain later.

The OpenAPI Generator doesn't just spew out code; it acts as a very strict guardian of your API contract.

- **No more manual DTO creation**: Forget the mind-numbing task of writing Data Transfer Objects (DTOs) by hand. Your API specification defines them, and the generator builds them perfectly, every single time. This kills off an entire category of typos and inconsistencies.
- **Trivial controller implementations**: Your Spring `@RestController` interfaces, with all their routing annotations, are also generated. This means your controller classes transition from boilerplate factories to minimalist components that simply _implement_ a predefined interface.
- **Compiler-enforced contract**: Because your DTOs and controller interfaces are direct reflections of your OpenAPI spec, the compiler becomes your strictest ally. A missing field, a changed type, an altered endpoint signature, will result in a compile error. It is impossible to break your API contract without immediate feedback.

So, yeah, it's a bit of a setup, but the payoff? Absolutely worth it.
